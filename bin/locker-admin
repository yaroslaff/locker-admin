#!/usr/bin/env python3

import argparse
from http import server
import os
import string
import datetime
import json
import sys
import random
import tempfile
import subprocess
import hashlib

from requests.exceptions import HTTPError
from http.server import  HTTPServer, SimpleHTTPRequestHandler

from locker_client import LockerClient


#
# TODO: use one redirect URI?
#
# --insecure
#

# global locker client instance
locker = None

class LockerRequestHandler(SimpleHTTPRequestHandler):
    def do_GET(self):

        if self.path == '/_config.js':                
            self.send_response(200)
            self.send_header("Content-type", "application/javascript")
            self.end_headers()    
            
            data = f"locker_addr = '{locker.base_url}'\n"

            self.wfile.write(data.encode())

        else:
            return super().do_GET()

def get_args():

    def_apps = os.getenv('LOCKER_APPS_PATH', '/opt/locker-apps')
    def_api_key = os.getenv('LOCKER_KEY', None)
    def_host = os.getenv('LOCKER_HOST', None)
    def_bind = os.getenv('LOCKER_BIND','0.0.0.0:8000')

    parser = argparse.ArgumentParser(description='Locker admin')

    g = parser.add_argument_group('client-side file commands')
    g.add_argument('-d', '--download', nargs=2, metavar=('src', 'dst'), 
        help='recursive download remote SRC to DST, e.g. -d etc/ /tmp/l')
    g.add_argument('-u', '--upload', nargs=2, metavar=('src', 'dst'), 
        help='recursive upload SRC to remote DST, e.g. -u /tmp/l etc/')
    g.add_argument('--cat', metavar='RPATH', 
        help='cat remote file, e.g. --cat etc/options.json')
    g.add_argument('--edit', metavar='RPATH', 
        help='edit remote file (with $EDITOR or vi), e.g. --edit etc/options.json')
    g.add_argument('--rm', metavar='RPATH', 
        help='delete remote file')
    g.add_argument('--mkdir', metavar='RPATH', 
        help='create directory')
    g.add_argument('-l', '--list', metavar='RPATH', nargs='?', const='/',
        help='recursive list of remote path')
    g.add_argument('-j', '--jlist', metavar='RPATH', nargs='?', const='/',
        help='recursive JSON list of remote path')
            
    g = parser.add_argument_group('client-side app management')
    g.add_argument('--deploy', metavar='PATH', nargs='?', const='.',
        help='Deploy app config to locker server')
    g.add_argument('--serve', metavar='PATH', nargs='?', const='.',
        help='Run static webserver for application')
        
    g = parser.add_argument_group('client-side options')
    g.add_argument('--key', metavar='KEY', default=def_api_key,
        help='Use this X-API-KEY header: $LOCKER_API_KEY={}'.format(def_api_key))
    g.add_argument('--host', metavar='HOST', default=def_host,
        help='Your locker hostname: $LOCKER_HOST={}'.format(def_host))
    g.add_argument('-r', '--recursive', default=False, action='store_true', 
        help='recursive flag for download/upload/list/jlist')
    g.add_argument('--bind', default='0.0.0.0:8000',
        help=f'http address for --serve ({def_bind}')
    g.add_argument('--insecure-ssl', default=False, action='store_true',
        help=f'Do not verify server-side certificate')


    g = g.add_argument_group('nested')
    g.add_argument('-z')

    g = parser.add_argument_group('server-side arguments (for locker server admin)')
    g.add_argument('--apps', default=def_apps, help='Path to apps ($LOCKER_APPS_PATH={})'.format(def_apps))
    g.add_argument('--create', metavar=('user', 'app_name'), nargs=2, help='Create application directory: --create user1 test')

    return parser.parse_args()

def file_md5(path):
    hash = hashlib.md5()
    with open(path, "rb") as fh:
        content = fh.read()
        hash.update(content)
    
    return hash.hexdigest()

def mkdir(rpath):
    r = locker.mkdir(rpath)
    print(r.text.rstrip())

def download(rpath, lpath):
    stat = locker.stat(rpath)
    
    if rpath.endswith('/'):
        rpath=rpath[:-1]

    if stat.type == 'FILE':
        if os.path.isdir(lpath):
            lfilename = os.path.join(lpath,os.path.basename(rpath))
        else:
            lfilename = lpath
        
        r = locker.get(rpath, stream=True)
        with open(lfilename, "wb") as fh:
            for chunk in r.iter_content(chunk_size=8192): 
                fh.write(chunk)
        print(lfilename)

    elif stat.type == 'DIR':
        r = locker.get(rpath, stream=True)
        r.raise_for_status()

        if os.path.isdir(lpath):
            ldir = os.path.join(lpath, os.path.basename(rpath))
        else:
            ldir = lpath

        if not os.path.isdir(ldir):
            print(f"{ldir}/")
            os.mkdir(ldir)

        content = r.json()
        for k in content:
            download(os.path.join(rpath, k), ldir)


def upload(lpath, rpath):
    # print(f"UPLOAD l:{lpath} r:{rpath}")

    if rpath.endswith('/'):
        rpath=rpath[:-1]

    if lpath.endswith('/'):
        lpath=lpath[:-1]

    if os.path.isdir(lpath):
        target = os.path.join(rpath, os.path.basename(lpath) )
        locker.mkdir(target)
        for f in os.listdir(lpath):
            upload(os.path.join(lpath, f), target)
    
    elif os.path.isfile(lpath):
        try:
            stat = locker.stat(rpath)
            if stat.type == 'DIR':
                rpath = os.path.join(rpath, os.path.basename(lpath))
        except HTTPError as e:
            if e.response.status_code == 404:
                # everything fine
                pass

        print(f"{lpath} > {locker.host}:{rpath}")
        with open(lpath,'r') as fh:
            data = fh.read()
            locker.put(rpath, data)

def cat(rpath):
    r = locker.get(rpath, stream=True)
    print(r.text.rstrip())

def rm(rpath, recursive=False):
    r = locker.rm(rpath, recursive=recursive)
    print(r.text.rstrip())

def edit(rpath):
    r = locker.get(rpath, stream=True)
    editor = os.getenv('EDITOR','vi')

    # get suffix from rpath
    splitted = rpath.rsplit('.',1)
    if len(splitted) == 2:
        suffix = '.'+splitted[1]
    else:
        suffix = '.txt'

    # download
    fh = tempfile.NamedTemporaryFile(prefix='locker-admin-edit-', suffix=suffix, delete=False)
    lfname = fh.name 
    fh.write(r.content)
    fh.close()

    original_digest = file_md5(lfname)

    editor_command = list(filter(None, editor.split(' ')))
    editor_command.append(lfname)

    while True:
        verified = True
        # edit
        rc = subprocess.run(editor_command)

        new_digest = file_md5(lfname)
        
        if new_digest == original_digest:
            print("File not changed")
            return

        if rpath.endswith('.json'):
            with open(lfname, "r") as fh:
                try:
                    json.load(fh)
                except ValueError as e:
                    input(f"JSON check failed: {e}. Press ENTER and fix error.")
                    verified = False
        
        if verified:
            # upload
            upload(lfname, rpath)
            return
        else:
            print("Skip uploading")


def remote_jlist(path, recursive=False):
    r = list()
    stat = locker.stat(path)
    if stat.type == 'DIR':
        content = locker.get(path).json()
        l = list()
        for e in content:
            ce = content[e]
            ce['basename'] = e
            if recursive:
                ce['content'] = remote_jlist(os.path.join(path, e), recursive=recursive)
            l.append(ce)
        return l
    else:
        return stat.__dict__

def remote_list(path, recursive=False):
    def print_e(e, prefix=0):
        if e['type']=='FILE':
            print(f"{'':<{prefix}}{e['basename']:<{60-prefix}}sz:{e['size']} mt:{e['mtime']}")
        elif e['type']=='DIR':
            print(f"{'':<{prefix}}{e['basename']+'/':<{60-prefix}}DIR mt:{e['mtime']}")
            if 'content' in e:
                for ee in e['content']:
                    print_e(ee, prefix+2)

    l = remote_jlist(path, recursive=recursive)
    if isinstance(l, list):
        for ll in l:
            print_e(ll)
    else:
        print_e(l)


def gen_key(length=40):
    alphabet = string.ascii_lowercase + string.ascii_uppercase + string.digits
    key = ''.join(random.choice(alphabet) for i in range(length))
    return key

def create(apps, user, name, key=None):
    
    subdirs = ['etc', 'etc/skeleton', 'etc/skeleton/r', 'etc/skeleton/rw', 'home', 'var']

    print(f'Create app {name} in {apps}')
    if apps is None:
        print('set $LOCKER_APPS_PATH or --apps PATH to application directory')
        return

    if not os.path.isdir(apps):
        print(f'No apps_path. do: mkdir {apps} or specify correct --apps PATH')
        return

    userdir = os.path.join(apps, user) 
    appdir = os.path.join(apps, user, name) 

    if not os.path.isdir(userdir):
        os.mkdir(userdir)
    
    if os.path.isdir(appdir):
        print(f"{appdir} already exists. locker-admin will not delete it. do: rm -r {appdir}")
        return
    
    print("create", appdir)
    os.mkdir(appdir)
    for subdir in subdirs:
        dir = os.path.join(appdir, subdir)
        print("create", dir)
        os.mkdir(dir)
        # os.mkdir(os.path.join)



    key = key or gen_key()
    print("Generate API key in etc/keys.json")
    # generate keys
    keys = [
            {
                'key': key,
                'comment': 'Initial key, generated by locker-admin',
                'created': datetime.datetime.now().strftime('%Y/%m/%d'),
                'touched': datetime.datetime.now().strftime('%Y/%m/%d'),
                'ip': []
            }
        ]

    print("MASTER KEY:", key)

    with open(os.path.join(appdir, 'etc/keys.json'), 'w') as fh:
        json.dump(keys, fh, indent=4)

    print("Generate etc/options.json")
    options = {
        'origins': [],
    	"query-options": [

            {
                "filter_method": "GET",                
                "headers": {
                    "Cache-Control": "no-cache, no-store, must-revalidate"
                }
            },

            {
                "filter_method": "PUT",
                "filter_path": "${HOME}/rw/",
                
                "options": {
                    "create": True,
                    "max_content_length": 1024,
                    "set_flag": {
                        "file": "flags.json",
                        "flag": "notebook"
                    }
                },
            }
	    ],
        "accept_new_users": True,
        "noregister_url": "http://google.com/",
    }

    with open(os.path.join(appdir, 'etc/options.json'), 'w') as fh:
        json.dump(options, fh, indent=4)

    print("Generate etc/oidc_credentials.json")
    oidc_credentials = {
        "vendor": ["google"]
    }

    with open(os.path.join(appdir, 'etc/oidc_credentials.json'), 'w') as fh:
        json.dump(oidc_credentials, fh, indent=4)

    print("Generate etc/users.json")
    users_data = {
        "bindings": {
        },
        "control": {
            "last": 0
        }
    }

    with open(os.path.join(appdir, 'etc/users.json'), 'w') as fh:
        json.dump(users_data, fh, indent=4)



def check_sanity(args):

    if ( args.cat or args.upload or args.download \
            or args.list or args.jlist or args.serve \
            or args.deploy or args.rm or args.mkdir) \
            and not locker:
        print("Need locker app details:")
        print(f"Key: --key or $LOCKER_KEY: {args.key}")
        print(f"Host: --host or $LOCKER_HOST: {args.host}")
        return False

    return True

def serve(path, bind):
    addr_port = bind.split(':')
    print(f"run static webserver {bind} at {path}")
    os.chdir(path)
    httpd = HTTPServer((addr_port[0], int(addr_port[1])), LockerRequestHandler)
    httpd.serve_forever()

def deploy(path):
    for dpath in ['etc/options.json', 'etc/skeleton', 'var']:
        local_path = os.path.join(path, '_locker_deploy/', dpath)
        if not os.path.exists(local_path):
            continue
        upload(local_path, os.path.dirname(dpath))

def main():
    global locker

    args = get_args()

    if args.host and args.key:
        locker = LockerClient(host=args.host, key=args.key, insecure=args.insecure_ssl)

    if not check_sanity(args):
        sys.exit(1)


    if args.create:
        create(apps=args.apps, user=args.create[0], name=args.create[1], key=args.key)

    if args.download:
        download(rpath=args.download[0], lpath=args.download[1])

    if args.upload:
        upload(lpath=args.upload[0], rpath=args.upload[1])

    if args.cat:
        cat(args.cat)

    if args.edit:
        edit(args.edit)

    if args.list:
        remote_list(args.list, recursive=args.recursive)
    
    if args.jlist:
        r = remote_jlist(args.jlist, recursive=args.recursive)
        print(json.dumps(r, indent=4))

    if args.serve:
        serve(args.serve, args.bind)

    if args.deploy:
        deploy(args.deploy)
    
    if args.mkdir:
        mkdir(args.mkdir)

    if args.rm:
        rm(args.rm, recursive=args.recursive)

main()
